# CPTS 487 - Software Design & Architecture

# Instructor and TA Information
- **Instructor**: Bolong Zeng
  - **Email**: bzeng@wsu.edu

# Required and Recommended Textbooks

## Required:
- **[BASS]** L. Bass, P. Clements, R. Kazman. *Software Architecture in Practice*, 3rd ed., Addison-Wesley, 2012.
- **[GAMMA]** E. Gamma, R. Helm, R. Johnson, J. Vlissides. *Design Patterns: Elements of Reusable Object-Oriented Software*, 1st ed., Addison-Wesley, 1994.

## Recommended:
- **[MARTIN]** R. C. Martin. *Agile Software Development: Principles, Patterns, and Practices*, 1st ed., Pearson, 2002.
- **[CLEMENTS]** P. Clements et al., *Documenting Software Architectures: Views and Beyond*, 2nd ed., Pearson Education, 2010.

# Additional Resources
- **MonoGame Documentation**: [MonoGame Docs](http://www.monogame.net/documentation/?page=main)
- **LibGDX Documentation**: [LibGDX Docs](https://libgdx.badlogicgames.com/documentation/)
- **GameFromScratch Tutorials**:  
  - [MonoGame Tutorials](https://www.gamefromscratch.com/page/MonoGame-Tutorial-Series.aspx)
  - [LibGDX Tutorials](https://www.gamefromscratch.com/page/LibGDX-Tutorial-series.aspx)
- **Design Patterns Reference**: [OODesign](https://www.oodesign.com/)

# Course Overview
**CptS 487 - Software Design & Architecture** focuses on fundamental software design principles and methodologies. Students will learn how to build and document both the static and dynamic aspects of software design, apply common solutions to recurring design problems, and recognize poor design solutions. The course also covers evaluating software quality, different architectural styles, and good and poor architectural practices.

# Learning Outcomes
By the end of the course, students will be able to:
1. Explain key software design concepts and construct professional design documents.
2. Apply software design principles.
3. Design software systems considering concurrency, security, and data persistence.
4. Identify and apply design patterns; recognize and propose solutions to poor design decisions.
5. Critique software designs based on quality attributes and apply evaluation techniques.
6. Describe software architectural styles and select appropriate ones for specific systems.
7. Identify reusable components for software development.
8. Apply common architectural patterns appropriately.
9. Produce architectural diagrams representing various system views.

# Mapping Student Learning Outcomes to Course Content

| **Learning Outcome** | **Course Topics/Dates**                                     | **Evaluation Method**           |
|----------------------|-------------------------------------------------------------|---------------------------------|
| 1                    | Software design concepts and documentation (Weeks 1, 2, 3, 4, 9) | Homework, Project               |
| 2                    | Software design principles (Weeks 3, 4)                     | Homework, Project, Midterm      |
| 3                    | Key issues during design (Week 7)                           | Project, Final Exam             |
| 4                    | Design patterns and anti-patterns (Weeks 2, 3, 6, 9, 13)    | Homework, Project, Midterm      |
| 5                    | Software design quality (Week 8)                            | Project, Final Exam             |
| 6                    | Software architectural styles (Weeks 10, 11)                | Homework, Project, Final Exam   |
| 7                    | Software reuse; libraries, frameworks, and components (Weeks 11, 12) | Project                       |
| 8                    | Architectural patterns and anti-patterns (Weeks 10, 11, 12) | Homework, Final Exam            |
| 9                    | Documenting software architecture (Weeks 10, 11, 12)        | Weekly Discussion, Project      |

# Prerequisites
- CptS 321 & 322 with a C or better.
- Familiarity with UML diagrams and tools; knowledge of Git version control.

# Attendance Policy
Attendance is mandatory, with participation points awarded through in-class quizzes or activities. Classes will be recorded and available online, but students are encouraged to attend in-person for more interactive learning. Make-up exams are generally not provided without prior notification to the instructor.

# Project and Homework
- **Project**: Teams of 4-5 students will work on a semester-long project, with progress measured by milestones. Each milestone may require written reports, code submissions, or test cases. Late submissions incur a 10% point deduction per day, up to one week late, with exceptions requiring valid excuses.
- **Homework**: There will be 4-5 homework assignments. Submissions must be in PDF or image format and submitted via Canvas by midnight of the due date. Late submissions also incur a 10% point deduction per day, up to one week late, with prior instructor approval.

# Exams
- **Midterm**: Covers all material up to the exam date, to be scheduled around Week 7-8.
- **Final Exam**: Scheduled for Monday, April 29, 2024, from 10:30 am - 12:30 pm.

# Grading

- **Midterm**: 20%
- **Final Exam**: 20%
- **Project**: 40%
- **Homework Assignments**: 20%

# Grading Scale

| **Score**            | **Grade**  |
|----------------------|------------|
| 93% - 100%           | A          |
| 90% - 92.99%         | A-         |
| 86% - 89.99%         | B+         |
| 83% - 85.99%         | B          |
| 80% - 82.99%         | B-         |
| 76% - 79.99%         | C+         |
| 73% - 75.99%         | C          |
| 70% - 72.99%         | C-         |
| 66% - 69.99%         | D+         |
| 60% - 65.99%         | D          |
| 0% - 59%             | F          |

**Team vs. Individual Performance**: All team members are expected to contribute equally. If disparities in performance are identified, individual grades may be adjusted accordingly.

# Workload Expectation
CptS 487 is a 3-credit course, implying an expectation of 9 hours per week of combined lecture and homework/project time.

# ABET Student Learning Outcomes
- **A**: Ability to apply knowledge of computing and mathematics to software system design and development.
- **B**: Ability to analyze problems and define computing requirements.
- **C**: Ability to design, implement, and evaluate computer-based systems to meet desired needs.
- **F**: Ability to communicate effectively with various audiences.
- **I**: Ability to use current techniques, skills, and tools necessary for computing practice.
