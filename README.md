# Lectures & Modules 



### [Lesson 1: Course Overview and Introduction to Git](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson1.pdf)
- **Topics Covered**:

  - Introduction to the course, expectations, and project work.
    
  - Overview of version control systems with a focus on Git.
    
  - Importance of using Git for collaborative coding projects.
    
  - Basic Git commands: init, add, commit, push, pull, branch, and merge.
    
  - Setting up a Git repository on EECS Gitlab.

- Purpose: To familiarize students with the course structure, Git usage, and team collaboration tools.

---
### [Lesson 2: Object-Oriented Basics](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson2-OOBasics.pdf)
- **Topics Covered**:
  
  - Fundamental concepts of object-oriented programming (OOP).
    
  - Differences between procedural and object-oriented approaches.
    
  - Core OOP principles: encapsulation, inheritance, polymorphism, and abstraction.
    
  - Understanding classes, objects, methods, and attributes.
    
  - Importance of designing software around objects and their interactions.
    
- **Purpose**: To reinforce OOP concepts crucial for understanding software design and architecture

---
### [Lesson 4: Design Patterns - Factory Pattern](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson4-DesignPatterns1-Factory.pdf)
- **Topics Covered**:

  - Introduction to design patterns with a focus on the Factory Pattern.

  - Explanation of how the Factory Pattern provides a way to create objects without specifying the exact class of object that will be created.

  - Use cases and examples of the Factory Pattern in software design.

- **Purpose**: To teach students how to use the Factory Pattern to create flexible and reusable code.



---
### [Lesson 5: Design Patterns - Abstract Factory Pattern](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson5-DesignPatterns2-AbstractFactory.pdf)
- **Topics Covered**:

  - Deep dive into the Abstract Factory Pattern.

  - How Abstract Factory differs from the Factory Pattern.

  - Scenarios where Abstract Factory is more appropriate than other creational patterns.

  - Implementation examples and benefits of using the Abstract Factory Pattern.

- **Purpose**: To extend the understanding of creational design patterns by introducing more complex patterns like Abstract Factory.




---
### [Lesson 6: Design Principles](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson6-DesignPrinciples.pdf)
- **Topics Covered**:

  - Introduction to key software design principles like cohesion and coupling.

  - Understanding the importance of high cohesion and low coupling in software systems.

  - How to apply these principles in the design phase to create robust and maintainable software.

- **Purpose**: To instill fundamental design principles that lead to better software architecture



---
### [Lesson 7: Object-Oriented Design Principles](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson7-OODesignPrinciples.pdf)
- **Topics Covered**:

  - Five key object-oriented design principles: SRP (Single Responsibility Principle), OCP (Open-Closed Principle), LSP (Liskov Substitution Principle), DIP (Dependency Inversion Principle), and ISP (Interface Segregation Principle).

  - Practical examples and applications of these principles.

  - The importance of adhering to these principles to avoid common pitfalls in software design.

- **Purpose**: To provide a framework for students to create well-structured and maintainable object-oriented software​



---
### [Lesson 8: Object Modeling](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson8-ObjectModeling.pdf)
- **Topics Covered**:
  - Introduction to object modeling techniques.
    
  - How to represent and model objects, their relationships, and interactions.

  - The use of UML (Unified Modeling Language) for creating object models.

  - Techniques for refining and optimizing object models to meet design requirements.

- **Purpose**: To teach students the skills needed to effectively model the objects within a software system, ensuring clarity and consistency in design

---
### [Lesson 9: Sequence Diagrams Basic](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson9-SequenceDiagramsBasic.pdf)
- **Topics**: Basic concepts and use of sequence diagrams in software design.

- **Details**: Introduction to sequence diagrams, which represent interactions between objects in a time sequence. It covers the key elements such as lifelines, messages, and activation boxes



---
### [Lesson 10: Analysis Case Study Pt. 1](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson10-AnalysisCaseStudy1.pdf)
- **Topics**: Requirements elicitation and analysis using a case study.

- **Details**: The lesson uses the "Plants vs Zombies" game as an example to explain how to gather requirements and analyze the stages needed for software development. It focuses on identifying use cases and class diagrams

---
### [Lesson 11: Analysis Case Study Pt. 2](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson11-AnalysisCaseStudy2%20(2).pdf)
- **Topics**: Continuation of the case study with emphasis on refining the analysis.

- **Details**: This lesson continues the analysis of the "Plants vs Zombies" case study, focusing on creating detailed sequence diagrams, statechart diagrams, and activity diagrams to refine the software requirements and identify necessary changes



---
### [Lesson 12: Design Patterns 3 - Composite](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson12-DesignPatterns3-Composite.pdf)
- **Topics**: Structural design pattern - Composite Pattern.

- **Details**: Introduction to the Composite design pattern, which is used to treat individual objects and compositions of objects uniformly. The lesson explains the structure, participants, and implementation issues related to the Composite pattern

---
### [Lesson 13: Design Patterns 4 - Builder & Singleton](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson13-DesignPatterns4-Builder%26Singleton.pdf)
- **Topics**: Creational design patterns - Builder and Singleton.

- **Details**: This lesson explains the Builder pattern, used for constructing complex objects, and the Singleton pattern, ensuring that a class has only one instance. The differences between Builder and Factory/Abstract Factory patterns are also discussed

---
### [Lesson 14: Design Patterns 5 - Command & Memento](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson14-DesignPatterns5-Command%26Memento.pdf)
- **Topics**: Behavioral design patterns - Command and Memento.

- **Details**: The Command pattern encapsulates a request as an object, allowing for parameterization and supporting undoable operations. The Memento pattern captures and externalizes an object's internal state without violating encapsulation, enabling the object to be restored to this state later

---
### [Lesson 15: Introduction to Software Architecture](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson15-ArchitectureIntro.pdf)
- **Topics**: Fundamental concepts of software architecture.

- **Details**: The lesson introduces software architecture, emphasizing the importance of designing a stable architecture that allows for maintainability and extension. It discusses subsystems, components, services, and interfaces, and introduces the use of UML diagrams for architectural modeling


---
### [Lesson 16: Architectural Pattern 1](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson16-ArchitecturalPattern1.pdf)
- **Topics**: Introduction to common architectural patterns.

- **Details**: This lesson delves into architectural patterns or styles that allow for the design of flexible systems using components. It explains how these patterns help in organizing the overall structure of a system to improve maintainability and scalability

---
### [Lesson 17: Midterm Review](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson17-MidtermReview.pdf)
- **Topics**: Review of key concepts for the midterm exam.

- **Details**: A summary of the key concepts covered in the course up to this point, including OO and UML basics, design patterns, design principles (SOLID), and architecture concepts. This lesson prepares students for the midterm exam

---
### [Lesson 18: Quality Attributes](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson18-DesignQualities3.pdf)
- This lesson introduces and discusses various quality attributes important in software design, such as availability, performance, security, and testability. It outlines how these attributes influence the design and implementation of software systems and provides tactics to achieve them. For instance, availability is discussed in terms of minimizing service outages, while performance focuses on meeting timing requirements.

---
### [Lesson 21: System Design - Part 1](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson21-SystemDesign1.pdf)
- This lesson covers key issues in system design, particularly hardware/software mapping. It explains how to allocate resources, map objects to hardware, and handle the complexities that arise from hardware and software constraints. UML diagrams are used to illustrate deployment and component dependencies in a system.

---
### [Lesson 22: System Design - Part 2](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson22-SystemDesign2.pdf)
- This lesson continues the discussion on system design, focusing on persistent data management and access control. It explains how to map class diagrams to relational database tables and discusses different methods for implementing access control, such as access control lists and capabilities.

---
### [Lesson 23: System Design - Part 3](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson23-SystemDesign3.pdf)
- This lesson covers global control flow design, which includes procedure-driven control, event-driven control, and threaded control. Each control flow method is explained in terms of how it sequences actions in a system and the scenarios in which each is best applied.

---
### [Lesson 24: Design Patterns 8 - Façade & Bridge](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson24-DesignPatterns8_Facade%26Bridge.pdf)
- This lesson introduces the Façade and Bridge design patterns. The Façade pattern provides a simplified interface to a complex subsystem, making it easier to use. The Bridge pattern decouples an abstraction from its implementation, allowing them to vary independently, which is useful for systems requiring multiple implementations.

---
### [Lesson 25: Design Patterns 9 - Adapter & Strategy](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson25-DesignPatterns9_Adapter%26Strategy.pdf)
- This lesson covers the Adapter and Strategy design patterns. The Adapter pattern allows incompatible interfaces to work together, while the Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable, enabling the algorithm to vary independently from clients that use it.

---
### [Lesson 26: Design Patterns 10 - State & Flyweight]()
- This lesson discusses the State and Flyweight design patterns. The State pattern allows an object to alter its behavior when its internal state changes, while the Flyweight pattern uses sharing to support a large number of fine-grained objects efficiently, making it suitable for systems with many similar objects.

- These lessons cover crucial topics in software design, focusing on the practical application of design patterns and system design principles to create efficient, scalable, and maintainable software systems.
---
### [Lesson 27: Design Patterns 11 - Proxy & Visitor](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson26-DesignPatterns10_state%26flyweight.pdf)
- **Proxy Pattern**: Discusses the concept of providing a surrogate or placeholder for another object to control access to it. Different types of proxies like Remote Proxy, Virtual Proxy, Protection Proxy, and more are explored.

- **Visitor Pattern**: Explains how to represent an operation to be performed on the elements of an object structure, allowing new operations to be added without altering the classes of the elements on which it operates.
---
### [Lesson 28: Architectural Pattern 2](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson28-ArchitecturalPattern2.pdf)

- Focuses on more advanced architectural patterns in software design. This lesson likely covers specific patterns used in large-scale systems, discussing their structure, applicability, and implementation strategies.

---
### [Lesson 29: Object Design](https://github.com/MarkShinozaki/CPTS487-SoftwareDesign-Architecture/blob/Lectures-Slides/CptS487_Lesson29-ObjectDesign.pdf)
- **Object Design Activities**: Covers activities involved in object design, such as reuse, interface specification, restructuring, and optimization of the object model.

- **Reuse**: Discusses different types of reuse (white-box reuse through inheritance and black-box reuse through composition) and emphasizes favoring composition over inheritance for flexibility.

- **Principles of Object Design**: Introduces design principles like "Program to an Interface, Not an Implementation," and "Favor Composition Over Inheritance."

